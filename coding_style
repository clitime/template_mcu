1. Пробелы.

Использовать отступ в 4 пробела. TAB никогда не использовать. Кроме случаев,
где это требуется синтаксисом, например Makefile.

В операторе "switch" делать отступы на метках  "case" не нужно:

/**********************************************************/
    switch(suffix) {
    case 'A':
    case 'a':
        break;
    case 'B':
    case 'b':
        abb |= 0xf0;
        break;
    default:
        break;
    }
/**********************************************************/

2. Длина строки

Длина строки не должна превышать 80 символов

3. Именование

Переменные должны быть в camelStyle.
Локальные имена в пределах функции должны состоять из 1-го, максимум 2-х слов.
Имена, видимые в пределах файла, и тем более, глобальные имена, должны описывать
переменную четко и локанично: requestCountUart.

Имена переменных должны быть существительными.
Структурные типы именовать в PascalStyle.
Перечисляемые типы должны быть так же в PascalStyle_t.
Скалярные типы переменных в PascalStyle_t.
Константные макросы и переменные должны быть в ВЕРХНЕМ_РЕГИСТРЕ.

Имена функций должны быть глаголами, записанные, как и переменные,
в camelStyle().

4. typedef.

Использовать typedef можно для:
    - перечисляемых типов, добавляя в конце _t;
    - для скалярных типов, позволяющеих избежать проблем с переносимостью,
        добавляя в конце _t;
    - для объектов, свойства которых можно получить только с помощью функций;
    - возможно есть ситуации, когда еще необходимо использовать typedef.

если typedef использовать для структур, то сохранять имя структуры:

/**********************************************************/
    struct SheepsWolf {
        uint8_t wool;
        uint32_t size;
        char bleat[8];
    };

    typedef struct SheepsWolf SheepsWolf;

    SheepsWolf scoutWolf;
/**********************************************************/

5. Структура блоков.

Каждый блок операторов, который получается с помощью отступов, должен быть
заключен в скобочки, даже если блок состоит из одного оператора. Закрывающая
скобочка располагается на новой строке с оператором "else" и подобными или в
гордом одиночестве

/**********************************************************/
    if (a == 5) {
        b = 3;
    } else if (a == 15) {
        b = 5;
    } else {
        a = 0;
        b = 0;
    }

    do {
        /*something do*/
    } while(0);
/**********************************************************/

Функции оформлять так: открывающая скобочка располагается на той же строке, что
и объявление функции:

/**********************************************************/
    void newFunciton(void) {
        doSomething();
    }

    static void local_function(uint8_t loc_var) {
        doSomething2();
    }
/**********************************************************/

6. Функции.

Функции должны быть короткими и понятными. И делать одну вещь, и делать ее
хорошо. Размер функции не следует делать более 48 строк. Если ее длина превышает
максимальный размер, то стоит подумать, как можно сделать функцию короче и
проще.

Имя функции должно описывать, что функция делает, ёмко и коротко.

Если функция возвращает результат выполнения, как код ошибки, то 0 = success,
-0xXX =fail, +0xXX = возможный успешный результат, например длина массива,
если результат булевский (например, isEmptyArray(), isTimeout()),
то success = true (1), fail = false (0).

7. Макросы, перечисления, константы.

Константные макросы и члены перечисления именовать в ВЕРХНЕМ_РЕГИСТРЕ

/**********************************************************/
    enum {
        STATE_IDLE = 0x00,
        STATE_ALERT,
        STATE_WAIT,
        STATE_EXIT,
        STATE_NULL
    };

    #define BUFFER_SIZE 0xf3ab
/**********************************************************/

Перечисления предпочтительны для связывания нескольких констант в одну смысловую
группу.

Макросы, напоминающие функции, должны быть именованы в camelStyle (можно
конечно и в ВЕРХНЕМ, но все же лучше в верблюжем, потому что в будущем можно
define переделать в функцию, локальную, статическую или глобальную).

    #define shiftLeft(a, b) ((a) << (b))

Нельзя в макросах:
    - нарушать поток выполнения:

    #define bar(x)                  \
        do {                        \
            if (blaBla(x) < 0)      \
                return -1;          \
        } while(0)                  \

    - использовать магические локальные переменые:

    #define cool(val) bar(abracadabra, val)

    выглядит вроде хорошо, но код тяжело читаем;

    - проблемы с пространством имен, когда в макросах определяются локальные
    переменные

8. Комментарии.

Лучше использовать /**/ стиль.

Блочные комментарии должны выглядеть, как
    /*
     * похожий
     * на
     * этот
     */

Коментарий должен описывать, что делается, для чего, но не рассказывать как
делается, реализуется функция.

Для описания переменных можно использовать комментарий //.

    type_t eventCount = 56; // значение переменой не должно превышать 255

Но лучше будет так:

    /*
     * значение переменой не должно превышать 255
     */
     type_t eventCount = 56;

 Если необходимо закомментировать часть кода, то лучше использовать комментарий
 вида:

    #if 0
        code
        code
        ...
        code
    #endif
потому что убираемый код может содержать комментарии

9.
Если ситуация того требует, то правила можно нарушать.
Немножко ;-)
